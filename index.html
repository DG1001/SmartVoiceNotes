<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#3b82f6">
    <title>SmartVoice Notes - KI-gestützte Sprachnotizen</title>
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" href="./logo.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .note-card {
            transition: all 0.3s ease;
        }
        .note-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .pulse-recording {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <header class="mb-8">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <i class="fas fa-microphone-alt text-blue-500 text-2xl"></i>
                    <h1 class="text-2xl font-bold text-gray-800">Smart<span class="text-blue-500">Voice</span> Notes</h1>
                </div>
                <button id="exportBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md flex items-center">
                    <i class="fas fa-file-export mr-2"></i> Exportieren
                </button>
            </div>
        </header>

        <!-- API Key Input -->
        <div class="bg-white p-4 rounded-lg shadow-md mb-6" id="apiKeySection">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-lg font-semibold">OpenAI API Konfiguration</h2>
                <button id="toggleApiKeyBtn" class="text-blue-500 hover:text-blue-700">
                    <i class="fas fa-chevron-down" id="toggleApiKeyIcon"></i>
                </button>
            </div>
            <div id="apiKeyContent" class="hidden">
                <div class="flex flex-col sm:flex-row gap-3">
                    <input type="password" id="apiKeyInput" placeholder="Ihren OpenAI API-Key eingeben" 
                           class="flex-grow px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="saveApiKeyBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md">
                        <i class="fas fa-save mr-2"></i> Speichern
                    </button>
                </div>
                <p class="text-sm text-gray-500 mt-2">Ihr API-Key wird nur lokal im Browser gespeichert und nicht an uns übertragen.</p>
            </div>
            <div id="apiKeyStatus" class="text-sm text-green-600 flex items-center">
                <i class="fas fa-check-circle mr-2"></i>
                <span>API-Key ist gesetzt</span>
                <button id="changeApiKeyBtn" class="text-blue-500 hover:text-blue-700 ml-2 text-xs">
                    Ändern
                </button>
            </div>
        </div>

        <!-- CalDAV Configuration -->
        <div class="bg-white p-4 rounded-lg shadow-md mb-6" id="calDavSection">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-lg font-semibold">CalDAV Kalender Konfiguration</h2>
                <button id="toggleCalDavBtn" class="text-blue-500 hover:text-blue-700">
                    <i class="fas fa-chevron-down" id="toggleCalDavIcon"></i>
                </button>
            </div>
            <div id="calDavContent" class="hidden">
                <div class="flex flex-col gap-3">
                    <input type="url" id="calDavUrlInput" placeholder="CalDAV Server URL (z.B. https://nextcloud.example.com/remote.php/dav/calendars/username/calendar)" 
                           class="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input type="text" id="calDavUserInput" placeholder="Benutzername" 
                               class="flex-grow px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <input type="password" id="calDavPasswordInput" placeholder="Passwort" 
                               class="flex-grow px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <button id="saveCalDavBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md">
                        <i class="fas fa-save mr-2"></i> Speichern
                    </button>
                    <button id="testCalDavBtn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md">
                        <i class="fas fa-check-circle mr-2"></i> Verbindung testen
                    </button>
                </div>
                <div class="mt-3 p-3 bg-yellow-50 rounded-md text-sm">
                    <p class="font-medium text-yellow-700"><i class="fas fa-info-circle mr-1"></i> CORS-Hinweis:</p>
                    <p class="text-yellow-600 mt-1">Für die Verbindung zu Ihrem CalDAV-Server wird ein CORS-Proxy verwendet. Bitte aktivieren Sie den Proxy-Zugriff einmalig unter: 
                        <a href="https://cors-anywhere.herokuapp.com/corsdemo" target="_blank" class="text-blue-500 underline">cors-anywhere.herokuapp.com/corsdemo</a>
                    </p>
                </div>
                <p class="text-sm text-gray-500 mt-2">Ihre Kalender-Zugangsdaten werden nur lokal im Browser gespeichert und nicht an uns übertragen.</p>
            </div>
            <div id="calDavStatus" class="text-sm text-green-600 flex items-center hidden">
                <i class="fas fa-check-circle mr-2"></i>
                <span>CalDAV-Verbindung ist konfiguriert</span>
                <button id="changeCalDavBtn" class="text-blue-500 hover:text-blue-700 ml-2 text-xs">
                    Ändern
                </button>
            </div>
        </div>

        <!-- Recording Section -->
        <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 class="text-lg font-semibold mb-4">Neue Sprachnotiz erstellen</h2>
            <div class="flex justify-center items-center mb-4">
                <button id="recordBtn" class="bg-red-500 hover:bg-red-600 text-white px-6 py-3 rounded-full flex items-center">
                    <i class="fas fa-microphone mr-2"></i>
                    <span id="recordText">Aufnahme starten</span>
                </button>
                <button id="resumeBtn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-full mb-4 flex items-center hidden ml-3">
                    <i class="fas fa-play mr-2"></i>
                    <span>Fortsetzen</span>
                </button>
            </div>
            <div class="flex flex-col items-center w-full">
                <div id="recordingStatus" class="text-gray-500 mb-4 hidden">
                    <i class="fas fa-circle text-red-500 mr-2 pulse-recording"></i>
                    <span>Aufnahme läuft...</span>
                </div>
                <div id="transcriptContainer" class="w-full mb-4 hidden">
                    <h3 class="font-medium mb-2">Transkript:</h3>
                    <div id="transcript" class="bg-gray-100 p-3 rounded-md min-h-20"></div>
                </div>
                <div class="flex space-x-3 w-full">
                    <button id="saveBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md flex-1 hidden">
                        <i class="fas fa-save mr-2"></i> Speichern
                    </button>
                    <button id="analyzeBtn" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded-md flex-1 hidden">
                        <i class="fas fa-robot mr-2"></i> Mit KI analysieren
                    </button>
                </div>
            </div>
        </div>

        <!-- Notes List -->
        <div>
            <div class="flex flex-col sm:flex-row justify-end items-stretch sm:items-center space-y-2 sm:space-y-0 sm:space-x-2 mb-4">
                 <select id="categoryFilter" class="w-full sm:w-auto rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 text-sm py-1 px-2">
                     <option value="all">Alle Kategorien</option>
                     <!-- Categories will be added here dynamically -->
                 </select>
                 <select id="keywordFilter" class="w-full sm:w-auto rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 text-sm py-1 px-2">
                     <option value="all">Alle Keywords</option>
                     <!-- Keywords will be added here dynamically -->
                 </select>
            </div>
            <div id="notesList" class="space-y-4">
                <!-- Notes will be added here dynamically -->
                <div class="text-center py-10 text-gray-500" id="emptyState">
                    <i class="fas fa-notes-medical text-4xl mb-3"></i>
                    <p>Noch keine Notizen vorhanden. Starten Sie eine Aufnahme!</p>
                </div>
            </div>
        </div>

        <!-- Offline Alert -->
        <div id="offlineAlert" class="fixed bottom-4 right-4 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 rounded shadow-md hidden">
            <div class="flex">
                <div class="py-1"><i class="fas fa-wifi text-yellow-500 mr-3"></i></div>
                <div>
                    <p class="font-bold">Offline-Modus</p>
                    <p class="text-sm">Sie sind offline. Einige Funktionen sind möglicherweise eingeschränkt.</p>
                </div>
            </div>
        </div>

        <!-- Note Detail Modal -->
        <div id="noteModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-auto">
                <div class="p-6">
                    <div class="flex justify-between items-start mb-4">
                        <h3 class="text-xl font-bold" id="modalTitle">Notiz Details</h3>
                        <button id="closeModalBtn" class="text-gray-500 hover:text-gray-700">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <h4 class="font-medium text-gray-700 mb-1">Originaltext:</h4>
                            <p id="modalOriginalText" class="bg-gray-100 p-3 rounded-md"></p>
                        </div>
                        <div>
                            <h4 class="font-medium text-gray-700 mb-1">KI-Analyse:</h4>
                            <div id="modalAnalysis" class="bg-blue-50 p-3 rounded-md">
                                <div class="grid grid-cols-2 gap-4 mb-3">
                                    <div>
                                        <p class="text-sm text-gray-500">Kategorie:</p>
                                        <p id="modalCategory" class="font-medium"></p>
                                    </div>
                                    <div>
                                        <p class="text-sm text-gray-500">Schlüsselwörter:</p>
                                        <p id="modalKeywords" class="font-medium"></p>
                                    </div>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-500">Zusammenfassung:</p>
                                    <p id="modalSummary" class="mt-1"></p>
                                </div>
                            </div>
                        </div>
                        <!-- Event Details Section (only shown for events) -->
                        <div id="eventDetailsSection" class="hidden bg-green-50 p-3 rounded-md">
                            <h4 class="font-medium text-gray-700 mb-2">Termin-Details:</h4>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <p class="text-sm text-gray-500">Titel:</p>
                                    <p id="eventTitle" class="font-medium"></p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-500">Ort:</p>
                                    <p id="eventLocation" class="font-medium"></p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-500">Beginn:</p>
                                    <p id="eventStart" class="font-medium"></p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-500">Ende:</p>
                                    <p id="eventEnd" class="font-medium"></p>
                                </div>
                            </div>
                            <div class="mt-3">
                                <p class="text-sm text-gray-500">Beschreibung:</p>
                                <p id="eventDescription" class="mt-1"></p>
                            </div>
                            <div class="mt-3 flex justify-end">
                                <span id="eventSyncStatus" class="text-xs text-gray-500 mr-2"></span>
                                <button id="syncEventBtn" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded-md text-sm">
                                    <i class="fas fa-calendar-plus mr-1"></i> In Kalender speichern
                                </button>
                            </div>
                        </div>
                        <div class="flex justify-between space-x-2 pt-4">
                            <button id="modalAnalyzeBtn" class="text-purple-500 hover:text-purple-700 flex items-center" style="display: none;">
                                <i class="fas fa-robot mr-2"></i> Mit KI analysieren
                            </button>
                            <button id="deleteNoteBtn" class="text-red-500 hover:text-red-700 flex items-center">
                                <i class="fas fa-trash mr-2"></i> Löschen
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const recordBtn = document.getElementById('recordBtn');
        const resumeBtn = document.getElementById('resumeBtn'); // Added resume button
        const recordText = document.getElementById('recordText');
        const recordingStatus = document.getElementById('recordingStatus');
        const transcriptContainer = document.getElementById('transcriptContainer');
        const transcript = document.getElementById('transcript');
        const saveBtn = document.getElementById('saveBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const notesList = document.getElementById('notesList');
        const emptyState = document.getElementById('emptyState');
        const noteModal = document.getElementById('noteModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalOriginalText = document.getElementById('modalOriginalText');
        const modalCategory = document.getElementById('modalCategory');
        const modalKeywords = document.getElementById('modalKeywords');
        const modalSummary = document.getElementById('modalSummary');
        const modalAnalyzeBtn = document.getElementById('modalAnalyzeBtn');
        const deleteNoteBtn = document.getElementById('deleteNoteBtn');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const exportBtn = document.getElementById('exportBtn');
        const keywordFilter = document.getElementById('keywordFilter');
        const categoryFilter = document.getElementById('categoryFilter'); // Added category filter element

        // App State
        let notes = JSON.parse(localStorage.getItem('smartVoiceNotes')) || [];
        let currentTranscript = '';
        let baseTranscript = ''; // To store text before resuming
        let isRecording = false;
        let recognition;
        let selectedNoteId = null;
        let apiKey = localStorage.getItem('openaiApiKey') || '';
        let currentKeywordFilter = 'all'; // 'all' or the selected keyword
        let currentCategoryFilter = 'all'; // 'all' or the selected category
        
        // CalDAV Configuration
        let calDavUrl = localStorage.getItem('calDavUrl') || '';
        let calDavUser = localStorage.getItem('calDavUser') || '';
        let calDavPassword = localStorage.getItem('calDavPassword') || '';

        // Initialize
        apiKeyInput.value = apiKey;
        updateApiKeyUI();
        document.getElementById('calDavUrlInput').value = calDavUrl;
        document.getElementById('calDavUserInput').value = calDavUser;
        document.getElementById('calDavPasswordInput').value = calDavPassword;
        updateApiKeyUI();
        updateCalDavUI();
        updateKeywordFilterDropdown();
        updateCategoryFilterDropdown();
        renderNotes();

        // Web Speech API Setup
        function setupSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                alert("Ihr Browser unterstützt die Web Speech API nicht. Bitte verwenden Sie Chrome oder Edge.");
                return;
            }

            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'de-DE';

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // Append new results to the base transcript
                currentTranscript = baseTranscript + finalTranscript;
                transcript.textContent = baseTranscript + (finalTranscript || interimTranscript); // Show interim results appended
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                stopRecording();
                alert(`Fehler bei der Spracherkennung: ${event.error}`);
            };

            recognition.onend = () => {
                // Ensure UI updates even if recognition stops automatically
                if (isRecording) {
                    console.log("Recognition ended automatically, updating UI.");
                    stopRecording();
                }
            };
        }

        // Recording Control
        function startRecording(resume = false) {
            if (!recognition) setupSpeechRecognition();

            try {
                if (resume) {
                    baseTranscript = currentTranscript ? currentTranscript + ' ' : ''; // Add space if resuming
                } else {
                    baseTranscript = '';
                    currentTranscript = '';
                    transcript.textContent = '';
                }

                recognition.start();
                isRecording = true;
                // Update UI for active recording
                recordBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                recordBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                recordText.textContent = 'Aufnahme stoppen';
                recordBtn.classList.remove('hidden'); // Ensure record button is visible (as stop button)
                resumeBtn.classList.add('hidden'); // Hide resume button during recording
                recordingStatus.classList.remove('hidden');
                transcriptContainer.classList.remove('hidden');
                saveBtn.classList.add('hidden');
                analyzeBtn.classList.add('hidden');

            } catch (e) {
                console.error('Recording start failed:', e);
                alert('Aufnahme konnte nicht gestartet werden. Bitte Mikrofon freigeben.');
                isRecording = false; // Ensure state is correct on error
            }
        }

        function stopRecording() {
            if (recognition) {
                recognition.stop();
            }
            isRecording = false;
            recordBtn.classList.remove('bg-red-600', 'hover:bg-red-700'); // Stop button style
            recordBtn.classList.add('bg-red-500', 'hover:bg-red-600');   // Start button style
            recordingStatus.classList.add('hidden');

            const hasTranscript = currentTranscript.trim();
            if (hasTranscript) {
                recordText.textContent = 'Neue Aufnahme'; // Change text to indicate clearing
                resumeBtn.classList.remove('hidden'); // Show resume button
                saveBtn.classList.remove('hidden');
                analyzeBtn.classList.remove('hidden');
            } else {
                recordText.textContent = 'Aufnahme starten'; // Standard text
                resumeBtn.classList.add('hidden'); // Hide resume button if no transcript
                saveBtn.classList.add('hidden');
                analyzeBtn.classList.add('hidden');
            }
            recordBtn.classList.remove('hidden'); // Ensure start button is visible
        }

        // Note Management
        function saveNote() {
            if (!currentTranscript.trim()) return;

            const newNote = {
                id: Date.now().toString(),
                text: currentTranscript.trim(),
                createdAt: new Date().toISOString(),
                analyzed: false
            };

            notes.unshift(newNote);
            saveNotes();
            updateKeywordFilterDropdown(); // Update keyword filter options
            updateCategoryFilterDropdown(); // Update category filter options
            renderNotes(); // Render with current filters
            resetRecordingUI();
        }

        async function analyzeWithAI(text = null) {
            const textToAnalyze = text || currentTranscript.trim();
            if (!textToAnalyze) return;
            if (!apiKey) {
                alert('Bitte geben Sie zuerst einen OpenAI API-Key ein.');
                apiKeyInput.focus();
                return;
            }

            analyzeBtn.disabled = true;
            analyzeBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Analysiere...';

            try {
                const prompt = `Analysiere die folgende Notiz in deutscher Sprache und gib eine JSON-Antwort zurück mit:
- "category": Die passendste Kategorie (z.B. "Einkaufsliste", "Termin", "Idee", "Aufgabe", "Erinnerung")
- "keywords": 3-5 relevante Schlüsselwörter, kommagetrennt
- "summary": Eine kurze, prägnante Zusammenfassung des Inhalts

Falls es sich um einen Termin handelt, füge folgende zusätzliche Felder hinzu:
- "isEvent": true
- "eventDetails": {
  "title": Ein passender Titel für den Termin
  "location": Der Ort des Termins (falls erwähnt, sonst leer)
  "startDate": Das Startdatum und die Startzeit im ISO-Format (YYYY-MM-DDTHH:MM:SS)
  "endDate": Das Enddatum und die Endzeit im ISO-Format (YYYY-MM-DDTHH:MM:SS), standardmäßig 1 Stunde nach Beginn
  "description": Eine Beschreibung des Termins
}

Wenn Zeitangaben relativ sind (z.B. "morgen", "nächste Woche"), berechne das tatsächliche Datum basierend auf dem aktuellen Datum: ${new Date().toISOString().split('T')[0]}.

Notiz: ${textToAnalyze}`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [{ role: "user", content: prompt }],
                        temperature: 0.7,
                        response_format: { type: "json_object" }
                    })
                });

                if (!response.ok) {
                    throw new Error(`API-Fehler: ${response.status}`);
                }

                const data = await response.json();
                const analysis = JSON.parse(data.choices[0].message.content);

                // Wenn wir eine bestehende Notiz analysieren
                if (text && selectedNoteId) {
                    const noteIndex = notes.findIndex(n => n.id === selectedNoteId);
                    if (noteIndex !== -1) {
                        notes[noteIndex].analyzed = true;
                        notes[noteIndex].analysis = {
                            category: analysis.category,
                            keywords: analysis.keywords,
                            summary: analysis.summary
                        };
                        
                        // Wenn es ein Termin ist, füge die Termindaten hinzu
                        if (analysis.isEvent) {
                            notes[noteIndex].isEvent = true;
                            notes[noteIndex].eventDetails = analysis.eventDetails;
                            
                            // Aktualisiere die Modalansicht für Termine
                            updateEventDetailsInModal(analysis.eventDetails);
                        } else {
                            // Verstecke Termin-Details, falls vorhanden
                            document.getElementById('eventDetailsSection').classList.add('hidden');
                        }
                        
                        // Aktualisiere die Modalansicht
                        modalCategory.textContent = analysis.category;
                        modalKeywords.textContent = analysis.keywords;
                        modalSummary.textContent = analysis.summary;
                        modalAnalyzeBtn.style.display = 'none';
                    }
                } else {
                    // Erstelle eine neue Notiz
                    const newNote = {
                        id: Date.now().toString(),
                        text: textToAnalyze,
                        createdAt: new Date().toISOString(),
                        analyzed: true,
                        analysis: {
                            category: analysis.category,
                            keywords: analysis.keywords,
                            summary: analysis.summary
                        }
                    };
                    
                    // Wenn es ein Termin ist, füge die Termindaten hinzu
                    if (analysis.isEvent) {
                        newNote.isEvent = true;
                        newNote.eventDetails = analysis.eventDetails;
                    }
                    
                    notes.unshift(newNote);
                    resetRecordingUI();
                }
                saveNotes();
                updateKeywordFilterDropdown(); // Update keyword filter options
                updateCategoryFilterDropdown(); // Update category filter options
                renderNotes(); // Render with current filters
            } catch (error) {
                console.error('AI Analysis error:', error);
                alert('Fehler bei der KI-Analyse: ' + error.message);
            } finally {
                analyzeBtn.disabled = false;
                analyzeBtn.innerHTML = '<i class="fas fa-robot mr-2"></i> Mit KI analysieren';
            }
        }

        function deleteNote(id) {
            notes = notes.filter(note => note.id !== id);
            saveNotes();
            updateKeywordFilterDropdown(); // Update keyword filter options
            updateCategoryFilterDropdown(); // Update category filter options
            renderNotes(); // Render with current filters
            noteModal.classList.add('hidden');
        }

        function saveNotes() {
            localStorage.setItem('smartVoiceNotes', JSON.stringify(notes));
        }

        function saveApiKey() {
            apiKey = apiKeyInput.value.trim();
            localStorage.setItem('openaiApiKey', apiKey);
            updateApiKeyUI();
            alert('API-Key wurde gespeichert!');
        }

        function updateApiKeyUI() {
            const apiKeyContent = document.getElementById('apiKeyContent');
            const apiKeyStatus = document.getElementById('apiKeyStatus');
            const toggleApiKeyIcon = document.getElementById('toggleApiKeyIcon');
            
            if (apiKey) {
                apiKeyContent.classList.add('hidden');
                apiKeyStatus.classList.remove('hidden');
                toggleApiKeyIcon.classList.remove('fa-chevron-up');
                toggleApiKeyIcon.classList.add('fa-chevron-down');
            } else {
                apiKeyContent.classList.remove('hidden');
                apiKeyStatus.classList.add('hidden');
            }
        }
        
        function saveCalDavConfig() {
            calDavUrl = document.getElementById('calDavUrlInput').value.trim();
            calDavUser = document.getElementById('calDavUserInput').value.trim();
            calDavPassword = document.getElementById('calDavPasswordInput').value.trim();
            
            localStorage.setItem('calDavUrl', calDavUrl);
            localStorage.setItem('calDavUser', calDavUser);
            localStorage.setItem('calDavPassword', calDavPassword);
            
            updateCalDavUI();
            alert('CalDAV-Konfiguration wurde gespeichert!');
        }
        
        function updateCalDavUI() {
            const calDavContent = document.getElementById('calDavContent');
            const calDavStatus = document.getElementById('calDavStatus');
            const toggleCalDavIcon = document.getElementById('toggleCalDavIcon');
            
            if (calDavUrl && calDavUser && calDavPassword) {
                calDavContent.classList.add('hidden');
                calDavStatus.classList.remove('hidden');
                toggleCalDavIcon.classList.remove('fa-chevron-up');
                toggleCalDavIcon.classList.add('fa-chevron-down');
            } else {
                calDavContent.classList.remove('hidden');
                calDavStatus.classList.add('hidden');
            }
        }
        
        async function testCalDavConnection() {
            const testBtn = document.getElementById('testCalDavBtn');
            const url = document.getElementById('calDavUrlInput').value.trim();
            const username = document.getElementById('calDavUserInput').value.trim();
            const password = document.getElementById('calDavPasswordInput').value.trim();
            
            if (!url || !username || !password) {
                alert('Bitte füllen Sie alle CalDAV-Konfigurationsfelder aus.');
                return;
            }
            
            testBtn.disabled = true;
            testBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Teste Verbindung...';
            
            try {
                // Verwende einen CORS-Proxy für die Anfrage
                const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
                const targetUrl = url;
                
                // Hinweis: Für die Produktionsumgebung sollte ein eigener Proxy-Server verwendet werden
                const response = await fetch(proxyUrl + targetUrl, {
                    method: 'PROPFIND',
                    headers: {
                        'Content-Type': 'application/xml; charset=utf-8',
                        'Depth': '0',
                        'Authorization': 'Basic ' + btoa(username + ':' + password),
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: '<?xml version="1.0" encoding="utf-8" ?>' +
                          '<d:propfind xmlns:d="DAV:">' +
                          '<d:prop><d:resourcetype/></d:prop>' +
                          '</d:propfind>'
                });
                
                if (response.ok || response.status === 207) {
                    alert('Verbindung zum CalDAV-Server erfolgreich hergestellt!');
                } else {
                    throw new Error(`HTTP-Fehler: ${response.status}`);
                }
            } catch (error) {
                console.error('CalDAV connection test error:', error);
                alert('Fehler bei der Verbindung zum CalDAV-Server: ' + error.message + 
                      '\n\nHinweis: Wenn Sie einen CORS-Fehler sehen, müssen Sie möglicherweise den CORS-Proxy aktivieren unter: https://cors-anywhere.herokuapp.com/corsdemo');
            } finally {
                testBtn.disabled = false;
                testBtn.innerHTML = '<i class="fas fa-check-circle mr-2"></i> Verbindung testen';
            }
        }

        function exportNotes() {
            if (notes.length === 0) {
                alert('Keine Notizen zum Exportieren vorhanden.');
                return;
            }

            const dataStr = JSON.stringify(notes, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `smartvoice-notes-${new Date().toISOString().slice(0,10)}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }

        function updateKeywordFilterDropdown() {
            const keywordCounts = {};
            notes.forEach(note => {
                if (note.analyzed && note.analysis && note.analysis.keywords) {
                    const keywords = note.analysis.keywords.split(',').map(k => k.trim().toLowerCase());
                    keywords.forEach(keyword => {
                        if (keyword) { // Ensure keyword is not empty
                           keywordCounts[keyword] = (keywordCounts[keyword] || 0) + 1;
                        }
                    });
                }
            });

            const sortedKeywords = Object.entries(keywordCounts)
                .sort(([, countA], [, countB]) => countB - countA)
                .map(([keyword]) => keyword);

            const topKeywords = sortedKeywords.slice(0, 10);

            // Clear existing options except the first one ("Alle Keywords")
            while (keywordFilter.options.length > 1) {
                keywordFilter.remove(1);
            }

            // Add top keywords
            topKeywords.forEach(keyword => {
                const option = document.createElement('option');
                option.value = keyword;
                // Capitalize first letter for display
                option.textContent = keyword.charAt(0).toUpperCase() + keyword.slice(1);
                keywordFilter.appendChild(option);
            });

            // Set the selected option based on the current filter state
            keywordFilter.value = currentKeywordFilter;
        }

        function updateCategoryFilterDropdown() {
            const categories = new Set();
            notes.forEach(note => {
                if (note.analyzed && note.analysis && note.analysis.category) {
                    categories.add(note.analysis.category);
                }
            });

            const sortedCategories = Array.from(categories).sort((a, b) => a.localeCompare(b));

            // Clear existing options except the first one ("Alle Kategorien")
            while (categoryFilter.options.length > 1) {
                categoryFilter.remove(1);
            }

            // Add categories
            sortedCategories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category; // Use category name directly
                categoryFilter.appendChild(option);
            });

            // Set the selected option based on the current filter state
            categoryFilter.value = currentCategoryFilter;
        }


        // UI Rendering
        function renderNotes() {
            const filteredNotes = notes.filter(note => {
                // Category filter
                const categoryMatch = currentCategoryFilter === 'all' ||
                                      (note.analyzed && note.analysis && note.analysis.category === currentCategoryFilter);

                // Keyword filter
                const keywordMatch = currentKeywordFilter === 'all' ||
                                     (note.analyzed && note.analysis && note.analysis.keywords &&
                                      note.analysis.keywords.split(',').map(k => k.trim().toLowerCase()).includes(currentKeywordFilter));

                return categoryMatch && keywordMatch;
            });

            if (filteredNotes.length === 0) {
                emptyState.classList.remove('hidden');
                notesList.innerHTML = '';
                return;
            }

            emptyState.classList.add('hidden');
            notesList.innerHTML = '';

            if (notes.length > 0 && filteredNotes.length === 0) {
                 // Show a specific message if notes exist but are filtered out
                 let filterMessage = "Keine Notizen entsprechen den aktuellen Filtern.";
                 if (currentCategoryFilter !== 'all' && currentKeywordFilter !== 'all') {
                     filterMessage = `Keine Notizen entsprechen der Kategorie "${currentCategoryFilter}" und dem Keyword "${currentKeywordFilter}".`;
                 } else if (currentCategoryFilter !== 'all') {
                     filterMessage = `Keine Notizen entsprechen der Kategorie "${currentCategoryFilter}".`;
                 } else if (currentKeywordFilter !== 'all') {
                     filterMessage = `Keine Notizen entsprechen dem Keyword "${currentKeywordFilter}".`;
                 }
                 emptyState.innerHTML = `
                    <i class="fas fa-filter text-4xl mb-3"></i>
                    <p>${filterMessage}</p>
                 `;
                 emptyState.classList.remove('hidden');
            } else if (notes.length === 0) {
                 // Original empty state
                 emptyState.innerHTML = `
                    <i class="fas fa-notes-medical text-4xl mb-3"></i>
                    <p>Noch keine Notizen vorhanden. Starten Sie eine Aufnahme!</p>
                 `;
                 emptyState.classList.remove('hidden');
            }


            filteredNotes.forEach(note => {
                const noteElement = document.createElement('div');
                noteElement.className = 'note-card bg-white p-4 rounded-lg shadow-sm cursor-pointer hover:shadow-md';
                noteElement.dataset.id = note.id;

                let keywordsHtml = '';
                if (note.analyzed && note.analysis.keywords) {
                    const keywords = note.analysis.keywords.split(',').map(k => k.trim());
                    keywordsHtml = keywords.map(k => 
                        `<span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded mr-1">${k}</span>`
                    ).join('');
                }

                // Zusätzliches Badge für Termine
                const eventBadge = note.isEvent ? 
                    `<span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded mr-1"><i class="fas fa-calendar-alt mr-1"></i> Termin</span>` : '';

                noteElement.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-medium truncate">${note.analyzed ? note.analysis.category : 'Neue Notiz'}</h3>
                        <span class="text-xs text-gray-500">${new Date(note.createdAt).toLocaleString()}</span>
                    </div>
                    <p class="text-gray-600 text-sm mb-2 line-clamp-2">${note.analyzed ? note.analysis.summary : note.text}</p>
                    <div class="flex justify-between items-center">
                        <div>${keywordsHtml}</div>
                        <div class="flex space-x-1">
                            ${eventBadge}
                            ${note.analyzed ? 
                              '<span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded"><i class="fas fa-robot mr-1"></i> KI-analyzed</span>' : 
                              '<span class="bg-gray-100 text-gray-800 text-xs px-2 py-1 rounded">Unbearbeitet</span>'}
                            ${note.eventSynced ? 
                              '<span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded"><i class="fas fa-check mr-1"></i> Synchronisiert</span>' : ''}
                        </div>
                    </div>
                `;

                noteElement.addEventListener('click', () => openNoteModal(note.id));
                notesList.appendChild(noteElement);
            });
        }

        function openNoteModal(id) {
            const note = notes.find(n => n.id === id);
            if (!note) return;

            selectedNoteId = id;
            modalOriginalText.textContent = note.text;
            
            if (note.analyzed) {
                modalCategory.textContent = note.analysis.category;
                modalKeywords.textContent = note.analysis.keywords;
                modalSummary.textContent = note.analysis.summary;
                modalAnalyzeBtn.style.display = 'none';
                
                // Wenn es ein Termin ist, zeige die Termin-Details an
                if (note.isEvent && note.eventDetails) {
                    updateEventDetailsInModal(note.eventDetails);
                } else {
                    document.getElementById('eventDetailsSection').classList.add('hidden');
                }
            } else {
                modalCategory.textContent = 'Nicht analysiert';
                modalKeywords.textContent = 'Nicht analysiert';
                modalSummary.textContent = 'Diese Notiz wurde noch nicht mit der KI analysiert.';
                modalAnalyzeBtn.style.display = 'flex';
                document.getElementById('eventDetailsSection').classList.add('hidden');
            }

            noteModal.classList.remove('hidden');
        }
        
        function updateEventDetailsInModal(eventDetails) {
            const eventDetailsSection = document.getElementById('eventDetailsSection');
            const eventTitle = document.getElementById('eventTitle');
            const eventLocation = document.getElementById('eventLocation');
            const eventStart = document.getElementById('eventStart');
            const eventEnd = document.getElementById('eventEnd');
            const eventDescription = document.getElementById('eventDescription');
            const syncEventBtn = document.getElementById('syncEventBtn');
            const eventSyncStatus = document.getElementById('eventSyncStatus');
            
            // Formatiere Datum und Uhrzeit für die Anzeige
            const formatDateTime = (isoString) => {
                if (!isoString) return 'Nicht angegeben';
                const date = new Date(isoString);
                return date.toLocaleString('de-DE', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            };
            
            eventTitle.textContent = eventDetails.title || 'Kein Titel';
            eventLocation.textContent = eventDetails.location || 'Kein Ort angegeben';
            eventStart.textContent = formatDateTime(eventDetails.startDate);
            eventEnd.textContent = formatDateTime(eventDetails.endDate);
            eventDescription.textContent = eventDetails.description || 'Keine Beschreibung';
            
            // Prüfe, ob der Termin bereits synchronisiert wurde
            const note = notes.find(n => n.id === selectedNoteId);
            if (note && note.eventSynced) {
                syncEventBtn.classList.add('hidden');
                eventSyncStatus.textContent = 'Termin wurde bereits in den Kalender eingetragen';
                eventSyncStatus.classList.remove('text-gray-500');
                eventSyncStatus.classList.add('text-green-600');
            } else {
                syncEventBtn.classList.remove('hidden');
                eventSyncStatus.textContent = '';
            }
            
            eventDetailsSection.classList.remove('hidden');
        }

        function resetRecordingUI() {
            currentTranscript = '';
            baseTranscript = ''; // Reset base transcript as well
            transcript.textContent = '';
            transcriptContainer.classList.add('hidden');
            saveBtn.classList.add('hidden');
            analyzeBtn.classList.add('hidden');
            resumeBtn.classList.add('hidden'); // Hide resume button
            recordText.textContent = 'Aufnahme starten'; // Reset button text
            recordBtn.classList.remove('hidden'); // Ensure start button is visible
        }

        // Offline detection
        const offlineAlert = document.getElementById('offlineAlert');
        
        function updateOnlineStatus() {
            if (navigator.onLine) {
                offlineAlert.classList.add('hidden');
            } else {
                offlineAlert.classList.remove('hidden');
            }
        }
        
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
        updateOnlineStatus(); // Initial check
        
        // CalDAV Funktionen
        async function createCalDavEvent(eventDetails) {
            if (!calDavUrl || !calDavUser || !calDavPassword) {
                alert('Bitte konfigurieren Sie zuerst Ihre CalDAV-Verbindung.');
                return false;
            }
            
            try {
                // Generiere eine eindeutige UID für den Termin
                const uid = 'smartvoice-' + Date.now() + '@smartvoice.app';
                
                // Formatiere Datum und Uhrzeit für iCalendar
                const formatICalDate = (isoString) => {
                    if (!isoString) return '';
                    const date = new Date(isoString);
                    return date.toISOString().replace(/[-:]/g, '').replace(/\.\d+/g, '');
                };
                
                const startDate = formatICalDate(eventDetails.startDate);
                const endDate = formatICalDate(eventDetails.endDate);
                const now = formatICalDate(new Date().toISOString());
                
                // Erstelle iCalendar-Daten
                const icalData = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//SmartVoice//NONSGML SmartVoice Notes//DE
BEGIN:VEVENT
UID:${uid}
DTSTAMP:${now}
DTSTART:${startDate}
DTEND:${endDate}
SUMMARY:${eventDetails.title || 'Neuer Termin'}
LOCATION:${eventDetails.location || ''}
DESCRIPTION:${eventDetails.description || ''}
END:VEVENT
END:VCALENDAR`;
                
                // Generiere einen Dateinamen für den Termin
                const filename = `${uid}.ics`;
                
                // Verwende einen CORS-Proxy für die Anfrage
                const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
                const targetUrl = calDavUrl.endsWith('/') ? calDavUrl + filename : calDavUrl + '/' + filename;
                
                // Sende den Termin an den CalDAV-Server über den Proxy
                const response = await fetch(proxyUrl + targetUrl, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'text/calendar; charset=utf-8',
                        'Authorization': 'Basic ' + btoa(calDavUser + ':' + calDavPassword),
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: icalData
                });
                
                if (response.ok || response.status === 201 || response.status === 204) {
                    return true;
                } else {
                    throw new Error(`HTTP-Fehler: ${response.status}`);
                }
            } catch (error) {
                console.error('CalDAV event creation error:', error);
                alert('Fehler beim Erstellen des Termins: ' + error.message + 
                      '\n\nHinweis: Wenn Sie einen CORS-Fehler sehen, müssen Sie möglicherweise den CORS-Proxy aktivieren unter: https://cors-anywhere.herokuapp.com/corsdemo');
                return false;
            }
        }
        
        async function syncEventToCalendar() {
            if (selectedNoteId) {
                const note = notes.find(n => n.id === selectedNoteId);
                if (note && note.isEvent && note.eventDetails) {
                    const syncBtn = document.getElementById('syncEventBtn');
                    const eventSyncStatus = document.getElementById('eventSyncStatus');
                    
                    syncBtn.disabled = true;
                    syncBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> Synchronisiere...';
                    eventSyncStatus.textContent = 'Synchronisiere mit Kalender...';
                    eventSyncStatus.classList.add('text-gray-500');
                    
                    try {
                        const success = await createCalDavEvent(note.eventDetails);
                        if (success) {
                            // Markiere den Termin als synchronisiert
                            const noteIndex = notes.findIndex(n => n.id === selectedNoteId);
                            if (noteIndex !== -1) {
                                notes[noteIndex].eventSynced = true;
                                saveNotes();
                                renderNotes();
                            }
                            
                            eventSyncStatus.textContent = 'Termin wurde erfolgreich in den Kalender eingetragen';
                            eventSyncStatus.classList.remove('text-gray-500');
                            eventSyncStatus.classList.add('text-green-600');
                            syncBtn.classList.add('hidden');
                        } else {
                            eventSyncStatus.textContent = 'Synchronisierung fehlgeschlagen';
                            eventSyncStatus.classList.remove('text-gray-500');
                            eventSyncStatus.classList.add('text-red-600');
                        }
                    } catch (error) {
                        console.error('Event sync error:', error);
                        eventSyncStatus.textContent = 'Fehler: ' + error.message;
                        eventSyncStatus.classList.remove('text-gray-500');
                        eventSyncStatus.classList.add('text-red-600');
                    } finally {
                        syncBtn.disabled = false;
                        syncBtn.innerHTML = '<i class="fas fa-calendar-plus mr-1"></i> In Kalender speichern';
                    }
                }
            }
        }

        // Event Listeners
        recordBtn.addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                // Start a new recording, clearing existing transcript
                startRecording(false); 
            }
        });

        resumeBtn.addEventListener('click', () => {
            // Resume recording, appending to existing transcript
            startRecording(true);
        });

        saveBtn.addEventListener('click', saveNote);
        // Wrap analyzeWithAI in an anonymous function to prevent passing the event object
        analyzeBtn.addEventListener('click', () => analyzeWithAI()); 
        closeModalBtn.addEventListener('click', () => noteModal.classList.add('hidden'));
        modalAnalyzeBtn.addEventListener('click', async () => {
            if (selectedNoteId) {
                const note = notes.find(n => n.id === selectedNoteId);
                if (note && !note.analyzed) {
                    modalAnalyzeBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Analysiere...';
                    modalAnalyzeBtn.disabled = true;
                    try {
                        await analyzeWithAI(note.text);
                    } finally {
                        modalAnalyzeBtn.innerHTML = '<i class="fas fa-robot mr-2"></i> Mit KI analysieren';
                        modalAnalyzeBtn.disabled = false;
                    }
                }
            }
        });

        deleteNoteBtn.addEventListener('click', () => {
            if (selectedNoteId) {
                deleteNote(selectedNoteId);
            }
        });
        saveApiKeyBtn.addEventListener('click', saveApiKey);
        document.getElementById('saveCalDavBtn').addEventListener('click', saveCalDavConfig);
        document.getElementById('testCalDavBtn').addEventListener('click', testCalDavConnection);
        document.getElementById('syncEventBtn').addEventListener('click', syncEventToCalendar);
        exportBtn.addEventListener('click', exportNotes);

        keywordFilter.addEventListener('change', (e) => {
            currentKeywordFilter = e.target.value;
            renderNotes(); // Re-render notes with the new filter
        });

        categoryFilter.addEventListener('change', (e) => {
            currentCategoryFilter = e.target.value;
            renderNotes(); // Re-render notes with the new filter
        });
        
        // API Key UI controls
        document.getElementById('toggleApiKeyBtn').addEventListener('click', () => {
            const apiKeyContent = document.getElementById('apiKeyContent');
            const toggleApiKeyIcon = document.getElementById('toggleApiKeyIcon');
            
            apiKeyContent.classList.toggle('hidden');
            toggleApiKeyIcon.classList.toggle('fa-chevron-down');
            toggleApiKeyIcon.classList.toggle('fa-chevron-up');
        });
        
        document.getElementById('changeApiKeyBtn').addEventListener('click', () => {
            const apiKeyContent = document.getElementById('apiKeyContent');
            const toggleApiKeyIcon = document.getElementById('toggleApiKeyIcon');
            
            apiKeyContent.classList.remove('hidden');
            toggleApiKeyIcon.classList.remove('fa-chevron-down');
            toggleApiKeyIcon.classList.add('fa-chevron-up');
        });
        
        // CalDAV UI controls
        document.getElementById('toggleCalDavBtn').addEventListener('click', () => {
            const calDavContent = document.getElementById('calDavContent');
            const toggleCalDavIcon = document.getElementById('toggleCalDavIcon');
            
            calDavContent.classList.toggle('hidden');
            toggleCalDavIcon.classList.toggle('fa-chevron-down');
            toggleCalDavIcon.classList.toggle('fa-chevron-up');
        });
        
        document.getElementById('changeCalDavBtn').addEventListener('click', () => {
            const calDavContent = document.getElementById('calDavContent');
            const toggleCalDavIcon = document.getElementById('toggleCalDavIcon');
            
            calDavContent.classList.remove('hidden');
            toggleCalDavIcon.classList.remove('fa-chevron-down');
            toggleCalDavIcon.classList.add('fa-chevron-up');
        });

        // Close modal when clicking outside
        noteModal.addEventListener('click', (e) => {
            if (e.target === noteModal) {
                noteModal.classList.add('hidden');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !noteModal.classList.contains('hidden')) {
                noteModal.classList.add('hidden');
            }
        });
    </script>

    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
    </script>
</body>
</html>
